**中介者模式**是指用一个对象来封装一组对象之间的交互逻辑。中介者通过避免对象间显式的相互引用来增进不同对象间的松耦合，因此对象间的交互可以集中在一处控制，对象间的依存关系会减少。

**原型(Prototype)**应用复制操作的模式。复制指用同一模具生产一系列的产品，模具所基于的物品称为原型。原型决定了最终产品应该是什么样子。尽管产品是用同一模具复制的，但是某些属性，颜色尺寸之类，可以稍有不同。【原型就是实现对象的复制功能】

**工厂方法模式**定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。
何时使用:

* 编译时无法准确预期要创建的对象的类。
* 类想让其子类决定在运行时创建什么。
* 类有若干辅助类为其子类，而你想将返回哪个子类这一信息局部化。
工厂方法能够给予类在变更返回哪一种对象这一点上更多的灵活性。
**抽象工厂**提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

**抽象工厂和工厂方法对比**

抽象工厂：通过对象组合创建抽象产品；创建多系列产品；必须修改父类的接口才能支持新的产品。
工厂方法:通过类继承创建抽象产品；创建一种产品；子类化创建者并重载工厂方法以创建新产品。

---
创建抽象产品的工厂方法与创建抽象工厂的工厂方法的不同点。
像`intValue`和`boolValue`这样的工厂方法，应在具体工厂(`NSCFNumber`和`NSCFBoolean`)中重载以返回实际值(产品)。其他像`numberWithBool:`和`numberWithInt:`这样的工厂方法并不是为了返回产品，而是为了返回能返回产品的工厂，因此他们不应在具体子类中重载。

**生成器模式**将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。【客户(aClient)---承包商/指导者(aDirector)---建造者(aBuilder)】【“什么”和“如何”；构建什么对象；如何构建对象】

**生成器与抽象工厂的对比**
生成器:构建复杂对象；以多个步骤构建对象；以多种方式构建对象;在构建过程的最后一步返回产品；专注一个特定产品。
抽象工厂:构建简单或复杂对象；以单一步骤构建对象；以单一方式构建对象；立刻返回产品;强调一套产品。


**适配器模式**用于连接两种不同种类的对象，使其毫无问题的协同工作。**将一个类的接口转换为客户希望的另外一个接口，适配器模式使得原来由于接口不兼容而不能工作的那些类可以一起工作**(一边是客户端懂得如果使用的目标接口，另一边是客户端一无所知是被适配者，适配器站在两者之间。适配器的主要作用是将被适配者的行为传递给管道另一端的客户端)【将两个不同类的实例的不同的接口，通过适配器将其联系起来】
实现适配器的方式:
一:通过继承来适配两个接口，称为类适配器。
二:对象适配器:与类适配器不同，对象适配器不继承被适配者，而是组合了一个对他的引用。

类适配器与对象适配器对比:
类适配器:只针对单一的adaptee类，把Adaptee适配到Target；易于重载Adaptee的行为，因为是通过直接的子类话进行的适配；只有一个Adapter对象，无需额外的指针间接访问Adaptee

对象适配器:可以适配多个Adaptee及其子类；难以重载Adaptee的行为，需要借助于子类的对象而不是Adaptee本身;需要额外的指针以间接访问Adaptee并适配其行为。

**桥接模式**将抽象部分与它的实现部分分离，使他们都可以独立的变化

**外观模式**为系统中的一组接口提供一个统一的接口。外观定义一个高层接口，让子系统更易于使用。【将比较复杂的几个子系统(模块)通过一个更高的抽象类，将其功能组合起来供客户端使用】

**中介者模式**用一个对象来封装一系列对象的交互方式。中介者使各个对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互.(用于定义一个集中的场所，对象间的交互可以在一个中介者对象中处理。其他对象不必彼此交互。减少它们之间的依存关系。)

**观察者模式**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变的时候，多有依赖于它的对象得到通知并被自动更新。

**组合模式**将对象组合成树形结构以表示"部分-整体"的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。

122


















































